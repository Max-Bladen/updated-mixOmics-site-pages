cim(matrix(final.mbspls.model$X$rna))
cim(final.mbspls.model$X$rna)
cim(final.mbspls.model$X$rna)
network(final.mbspls.model)
network(final.mbspls.model, cutoff = 0.7)
network(final.mbspls.model, cutoff = 0.9)
typeof(mbspls)
typeof(final.mbspls.model)
network(final.mbspls.model, cutoff = 0.8)
network(final.mbspls.model, cutoff = 0.7)
circos(final.mbspls.model)
circosPlot(final.mbspls.model)
circosPlot(final.mbspls.model, cutoff = 0.5)
final.mbspls.model$X$methylation
circosPlot(final.mbspls.model, cutoff = 0.5)
length(NULL)
final.mbspls.model$X$Y
nrow(final.mbspls.model$X$Y)
circosPlot(final.mbspls.model, cutoff = 0.5, group = cell_metadata$lineage)
final.mbspls.model$Y
length(cell_metadata$lineage)
data("breast.TCGA")
data = list(mrna = breast.TCGA$data.train$mrna, mirna = breast.TCGA$data.train$mirna)
list.keepX = list(mrna = rep(20, 2), mirna = rep(10,2))
list.keepY = c(rep(10, 2))
TCGA.block.spls = block.spls(X = data,
Y = breast.TCGA$data.train$protein,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
circosPlot(TCGA.block.spls, group = breast.TCGA$data.train$subtype, cutoff = 0.7,
Y.name = 'protein')
load('Data/nmt_data_processed.RData')
X = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(50, 2), methylation = rep(50,2))
list.keepY = c(rep(10, 2))
yeet.block.spls = block.spls(X = X,
Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
X = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(50, 2), methylation = rep(50,2))
list.keepY = c(rep(10, 2))
yeet.block.spls = block.spls(X = X,
Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
X = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(50, 2), accessibility = rep(50,2))
list.keepY = c(rep(10, 2))
yeet.block.spls = block.spls(X = X,
Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
circosPlot(yeet.block.spls, group = cell_metadata$lineage, cutoff = 0.7,
Y.name = 'rna')
#circosPlot(final.mbspls.model, cutoff = 0.5, group = cell_metadata$lineage)
circosPlot(yeet.block.spls, group = cell_metadata$lineage, cutoff = 0.8,
Y.name = 'rna')
circosPlot(yeet.block.spls, group = cell_metadata$lineage, cutoff = 0.8,
Y.name = 'rna')
X = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(25, 2), accessibility = rep(25,2))
list.keepY = c(rep(10, 2))
yeet.block.spls = block.spls(X = X,
Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
circosPlot(yeet.block.spls, group = cell_metadata$lineage, cutoff = 0.8,
Y.name = 'rna')
circosPlot(yeet.block.spls, group = cell_metadata$lineage, cutoff = 0.9,
Y.name = 'rna')
circosPlot(final.mbspls.model.2, cutoff = 0.85,
Y.name = 'rna')
X.2 = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(25, 2), accessibility = rep(25,2))
list.keepY = c(rep(10, 2))
final.mbspls.model.2 = block.spls(X = X.2, Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
circosPlot(final.mbspls.model.2, cutoff = 0.85,
Y.name = 'rna')
circosPlot(final.mbspls.model.2, group = cell_metadata$lineage, cutoff = 0.85,
Y.name = 'rna')
circosPlot(final.mbspls.model.2, group = cell_metadata$lineage, cutoff = 0.8,
Y.name = 'rna')
circosPlot(final.mbspls.model.2, group = cell_metadata$lineage, cutoff = 0.8)
X.2 = list(methylation = data$met_genebody,
accessibility = data$acc_genebody)
list.keepX = list(methylation = rep(15, 2), accessibility = rep(15,2))
list.keepY = c(rep(15, 2))
final.mbspls.model.2 = block.spls(X = X.2, Y = data$rna,
ncomp = 2, keepX = list.keepX,
keepY = list.keepY, design = 'full')
circosPlot(final.mbspls.model.2, group = cell_metadata$lineage, cutoff = 0.8,
Y.name = 'rna')
library(mixOmics) # import the mixOmics library
data(srbct) # extract the small round bull cell tumour data
X <- srbct$gene # use the gene expression data as the X matrix
Y <- srbct$class # use the class data as the Y matrix
dim(X) # check the dimensions of the X dataframe
summary(Y) # check the distribution of class labels
Y
Y+1
classes <- unique(Y)
classes
length(Y)
sample(1:4, 63)
sample(1:4, 63, replace = TRUE)
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
Y
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
Y
summary(Y) # check the distribution of class labels
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
summary(Y) # check the distribution of class labels
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
summary(Y) # check the distribution of class labels
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
summary(Y) # check the distribution of class labels
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
summary(Y) # check the distribution of class labels
pca.srbct = pca(X, ncomp = 10, center = TRUE, scale = TRUE) # run pca method on data
plot(pca.srbct)  # barplot of the eigenvalues (explained variance per component)
plotIndiv(pca.srbct, group = srbct$class, ind.names = FALSE, # plot the samples projected
legend = TRUE, title = 'PCA on SRBCT, comp 1 - 2') # onto the PCA subspace
srbct$class
plotIndiv(pca.srbct, group = Y, ind.names = FALSE, # plot the samples projected
legend = TRUE, title = 'PCA on SRBCT, comp 1 - 2') # onto the PCA subspace
srbct.splsda <- splsda(X, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
## -------------------------------------------------------------------------------------------------------------------
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda , comp = 1:2,
group = srbct$class, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = '(a) PLSDA with confidence ellipses')
# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(srbct.splsda, comp.predicted=2, dist = "max.dist")
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda, comp = 1:2,
group = srbct$class, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = " (b) PLSDA with prediction background")
Y <- srbct$class # use the class data as the Y matrix
srbct.splsda <- splsda(X, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
## -------------------------------------------------------------------------------------------------------------------
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda , comp = 1:2,
group = srbct$class, ind.names = FALSE,  # colour points by class
ellipse = TRUE, # include 95% confidence ellipse for each class
legend = TRUE, title = '(a) PLSDA with confidence ellipses')
# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(srbct.splsda, comp.predicted=2, dist = "max.dist")
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda, comp = 1:2,
group = srbct$class, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = " (b) PLSDA with prediction background")
Y <- unique(Y)[sample(1:4, 63, replace = TRUE)]
srbct.splsda <- splsda(X, Y, ncomp = 10)  # set ncomp to 10 for performance assessment later
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda, comp = 1:2,
group = srbct$class, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = " (b) PLSDA with prediction background")
background = background.predict(srbct.splsda, comp.predicted=2, dist = "max.dist")
# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(srbct.splsda, comp = 1:2,
group = srbct$class, ind.names = FALSE, # colour points by class
background = background, # include prediction background for each class
legend = TRUE, title = " (b) PLSDA with prediction background")
## -------------------------------------------------------------------------------------------------------------------
library(mixOmics)
## -------------------------------------------------------------------------------------------------------------------
data(multidrug) # call multidrug dataset
X <- multidrug$ABC.trans # extract ABC transporter data
dim(X) # confirm the dimension of data
## ---- fig.cap= "FIGURE 1: Explained variance of Principal Components on the Multidrug ABC Transporter data"---------
trans.spca <- spca(X, ncomp = 10, center = TRUE, scale = TRUE) # run preliminary model
plot(trans.spca) # plot the explained variance per component
set.seed(5249) # for reproducibility with this case study, remove otherwise
test.keepX <- c(seq(5, 25, 5)) # set the number of variable values that will be tested
tune.spca.res <- tune.spca(X, ncomp = 3, # generate the first three components
nrepeat = 5, # repeat the cross-validation process five times
folds = 3, # use three folds for the cross-validation
test.keepX = test.keepX)
plot(tune.spca.res) # plot the optimisation output
test.keepX <- c(seq(5, 30, 5)) # set the number of variable values that will be tested
tune.spca.res <- tune.spca(X, ncomp = 3, # generate the first three components
nrepeat = 5, # repeat the cross-validation process five times
folds = 3, # use three folds for the cross-validation
test.keepX = test.keepX)
plot(tune.spca.res) # plot the optimisation output
## ---- fig.cap= "FIGURE 2: Tuning the number of variables to select with sPLCA on the ABC Transporter data."---------
set.seed(8589) # for reproducibility with this case study, remove otherwise
test.keepX <- c(seq(5, 30, 5)) # set the number of variable values that will be tested
tune.spca.res <- tune.spca(X, ncomp = 3, # generate the first three components
nrepeat = 5, # repeat the cross-validation process five times
folds = 3, # use three folds for the cross-validation
test.keepX = test.keepX)
plot(tune.spca.res) # plot the optimisation output
knitr::opts_chunk$set(echo = TRUE)
# run your analysis
nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
library(mixOmics)
data(nutrimouse)
nutrimouse
X <- nutrimouse$gene
Y <- nutrimouse$lipid
# run your analysis
nutri.res <- rcc(X, Y, ncomp = 3, lambda1 = 0.064, lambda2 = 0.008)
bisect = nutri.res$variates$X[, 1:3] + nutri.res$variates$Y[, 1:3]
bisect
nutri.res$variates$X
nutri.res$variates$Y
bisect
dim(X)
cord.X = cor(nutri.res$X, bisect, use = "pairwise")
cord.Y = cor(nutri.res$Y, bisect, use = "pairwise")
cord.X
?core
?cor
simMat
#
simMat = as.matrix(cord.X %*% t(cord.Y))
simMat
dim(simMat)
dim(cord.X)
dim9bisect
dim(bisect)
dim(nutri.res$X)
dim(cord.X)
cord.X
simMat
dim(simMat)
dim(bisect)
dim(cord.X)
dim(simMat)
dim(cord.Y)
## -------------------------------------------------------------------------------------------------------------------
library(mixOmics) # import the mixOmics library
data(srbct) # extract the small round bull cell tumour data
X <- srbct$gene # use the gene expression data as the X matrix
Y <- srbct$class # use the class data as the Y matrix
dim(X) # check the dimensions of the X dataframe
summary(Y)
train <- sample(1:nrow(X), 50) # randomly select 50 samples in training
test <- setdiff(1:nrow(X), train) # rest is part of the test set
# store matrices into training and test set:
X.train <- X[train, ]
X.test <- X[test,]
Y.train <- Y[train]
Y.test <- Y[test]
## -------------------------------------------------------------------------------------------------------------------
# train the model
train.splsda.srbct <- splsda(X.train, Y.train, ncomp = optimal.ncomp, keepX = optimal.keepX)
## -------------------------------------------------------------------------------------------------------------------
# use the model on the Xtest set
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = "mahalanobis.dist")
## -------------------------------------------------------------------------------------------------------------------
# train the model
train.splsda.srbct <- splsda(X.train, Y.train, ncomp = 2, keepX = c(25, 25))
## -------------------------------------------------------------------------------------------------------------------
# use the model on the Xtest set
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = "mahalanobis.dist")
predict.splsda.srbct$class
## -------------------------------------------------------------------------------------------------------------------
# use the model on the Xtest set
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = "centroids.dist")
predict.splsda.srbct$class
## -------------------------------------------------------------------------------------------------------------------
# train the model
train.splsda.srbct <- splsda(X.train, Y.train, ncomp = 3, keepX = c(25, 25, 25))
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = c("centroids.dist", "mahalanobis.dist"))
predict.splsda.srbct$class
save(predict.splsda.srbct$class, file = "splsdaSRBCTPredictions.RData")
## -------------------------------------------------------------------------------------------------------------------
# use the model on the Xtest set
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = "mahalanobis.dist")
predict.splsda.srbct <- predict(train.splsda.srbct, X.test, dist = c("centroids.dist", "mahalanobis.dist"))
save(predict.splsda.srbct, file = "splsdaSRBCTPredictions.RData")
X
Y
plsda.res = plsda(X, Y, ncomp = 3) # run the method
# calculate the correlation between Y
Rd.YvsU = cor(as.numeric(as.factor(Y)), plsda.res$variates$X[, 1:ncomp])
# calculate the correlation between Y
Rd.YvsU = cor(as.numeric(as.factor(Y)), plsda.res$variates$X[, 1:3])
Rd.YvsU
plsda.res$variates$X
Rd.YvsU = apply(Rd.YvsU^2, 2, sum)
plsda.res$variates$X
Rd.YvsU
# calculate the correlation between Y and each of the novel variates produced by the method
Rd.YvsU = cor(as.numeric(as.factor(Y)), plsda.res$variates$X)
Rd.YvsU
Rd.YvsU = apply(Rd.YvsU^2, 2, sum) #
Rd.YvsU
?sum
plsda.res$prop_expl_var
Rd.Y
Rd.Y = cbind(Rd.YvsU, cumsum(Rd.YvsU))
Rd.Y
data(linnerud)
X <- linnerud$exercise
Y <- linnerud$physiological[, 1:2]
linn.pls <- pls(X, Y, ncomp = 3)
pred <- predict(linn.pls, X[1:2, ])
pred$B.hat
X
Y
pred$variates
pred$B.hat
?spls
…
data(liver.toxicity) # extract the liver toxicity data
X <- liver.toxicity$gene # use the gene expression data as the X matrix
Y <- liver.toxicity$clinic # use the clinical data as the Y matrix
Y.mat <- unmap(Y) # creates a dummy matrix
res <- spls(X, Y.mat, ncomp = 3)
Y.mat <- unmap(Y) # creates a dummy matrix
Y
data(srbct) # extract the small round bull cell tumour data
X <- srbct$gene # use the gene expression data as the X matrix
Y <- srbct$class
Y.mat <- unmap(Y) # creates a dummy matrix
Y.mat
res <- spls(X, Y.mat, ncomp = 3)
val <- perf(res, criterion = c("R2", "Q2"))
val <- perf(res, criterion = c("R2", "Q2"), folds = 3)
val
val
?perf
library(knitr)
knitr::opts_chunk$set(dpi = 100, echo= TRUE, warning=FALSE, message=FALSE,
fig.show=TRUE, fig.keep = 'all', out.width = '90%')
library(mixOmics) # import the mixOmics library
data(srbct) # extract the small round bull cell tumour data
X <- srbct$gene # use the gene expression data as the X matrix
Y <- srbct$class # use the class data as the Y matrix - NON permuted
Yp <- sample(srbct$class) # use the class data as the Y matrix - permuted
optimal.ncomp <- 3
optimal.keepX <- c(9, 260, 30)
final.splsda.normal <- splsda(X, Y,
ncomp = optimal.ncomp,
keepX = optimal.keepX)
final.splsda.permuted <- splsda(X, Yp,
ncomp = optimal.ncomp,
keepX = optimal.keepX)
ProduceAveragedPerfMetrics <- function(X, Y, folds, bootstraps) {
metrics <- data.frame(matrix(0, nrow = 4, ncol = length(unique(Y))))
colnames(metrics) <- unique(Y)
rownames(metrics) <- c("error", "precision", "recall", "f1")
for (B in 1:bootstraps) {
testingProportion <- floor((1/folds)*nrow(X))
notTestedIdx <- 1:nrow(X)
for (fold in 1:folds) {
test <- sample(notTestedIdx, testingProportion) # randomly select samples in testing
train <- setdiff(1:nrow(X), test) # rest is part of the train set
# store matrices into training and test set:
X.train <- X[train, ]
X.test <- X[test,]
Y.train <- Y[train]
Y.test <- Y[test]
train.splsda <- splsda(X.train, Y.train, ncomp = optimal.ncomp, keepX = optimal.keepX)
predict.splsda <- predict(train.splsda, X.test, dist = "centroids.dist")
preds <- predict.splsda$class$centroids.dist[,optimal.ncomp]
conf.matrix <- table(factor(preds, levels = levels(Y)), Y.test)
for (class in unique(Y)) {
class = as.character(class)
df <- data.frame(conf.matrix)
tp <- conf.matrix[class, class]
tn.df <- df[which(as.character(df$Var1)!=class),]
tn.df <- tn.df[which(as.character(tn.df$Y.test)!=class),]
tn <- sum(tn.df$Freq)
fn.df <- df[which(as.character(df$Y.test) == class), ]
fn.df <- fn.df[which(as.character(fn.df$Var1) != class),]
fn <- sum(fn.df$Freq)
fp.df <- df[which(as.character(df$Var1) == class), ]
fp.df <- fp.df[which(as.character(fp.df$Y.test) != class),]
fp <- sum(fp.df$Freq)
error <- (fp+fn)/(tp+tn+fp+fn)
precision <- tp/(tp+fp)
recall <- tp/(tp+fn)
f1 <- (2*precision*recall)/(precision+recall)
if (is.na(precision)) {
precision = 0
}
if (is.na(recall)) {
recall = 0
}
if (is.na(f1)) {
f1 = 0
}
metrics[,class] <- metrics[,class] + c(error, precision, recall, f1)
}
notTestedIdx <- setdiff(notTestedIdx, test)
}
}
metrics["error",] <- metrics["error",]/bootstraps
metrics["precision",] <- metrics["precision",]/bootstraps
metrics["recall",] <- metrics["recall",]/bootstraps
metrics["f1",] <- metrics["f1",]/bootstraps
return(metrics)
}
normal.metrics <- ProduceAveragedPerfMetrics(X, Y, 5, 10)
permuted.metrics <- ProduceAveragedPerfMetrics(X, Yp, 5, 10)
print("Normal model performance metrics")
normal.metrics
print("Permuted model performance metrics")
permuted.metrics
normal.metrics
permuted.metrics
ProduceAveragedPerfMetrics <- function(X, Y, folds, bootstraps) {
metrics <- data.frame(matrix(0, nrow = 4, ncol = length(unique(Y))))
colnames(metrics) <- unique(Y)
rownames(metrics) <- c("error", "precision", "recall", "f1")
for (B in 1:bootstraps) {
testingProportion <- floor((1/folds)*nrow(X))
notTestedIdx <- 1:nrow(X)
for (fold in 1:folds) {
test <- sample(notTestedIdx, testingProportion) # randomly select samples in testing
train <- setdiff(1:nrow(X), test) # rest is part of the train set
# store matrices into training and test set:
X.train <- X[train, ]
X.test <- X[test,]
Y.train <- Y[train]
Y.test <- Y[test]
train.splsda <- splsda(X.train, Y.train, ncomp = optimal.ncomp, keepX = optimal.keepX)
predict.splsda <- predict(train.splsda, X.test, dist = "centroids.dist")
preds <- predict.splsda$class$centroids.dist[,optimal.ncomp]
conf.matrix <- table(factor(preds, levels = levels(Y)), Y.test)
for (class in unique(Y)) {
class = as.character(class)
df <- data.frame(conf.matrix)
tp <- conf.matrix[class, class]
tn.df <- df[which(as.character(df$Var1)!=class),]
tn.df <- tn.df[which(as.character(tn.df$Y.test)!=class),]
tn <- sum(tn.df$Freq)
fn.df <- df[which(as.character(df$Y.test) == class), ]
fn.df <- fn.df[which(as.character(fn.df$Var1) != class),]
fn <- sum(fn.df$Freq)
fp.df <- df[which(as.character(df$Var1) == class), ]
fp.df <- fp.df[which(as.character(fp.df$Y.test) != class),]
fp <- sum(fp.df$Freq)
error <- (fp+fn)/(tp+tn+fp+fn)
precision <- tp/(tp+fp)
recall <- tp/(tp+fn)
f1 <- (2*precision*recall)/(precision+recall)
if (is.na(precision)) {
precision = 0
}
if (is.na(recall)) {
recall = 0
}
if (is.na(f1)) {
f1 = 0
}
metrics[,class] <- metrics[,class] + c(error/folds, precision/folds, recall/folds, f1/folds)
}
notTestedIdx <- setdiff(notTestedIdx, test)
}
}
metrics["error",] <- metrics["error",]/bootstraps
metrics["precision",] <- metrics["precision",]/bootstraps
metrics["recall",] <- metrics["recall",]/bootstraps
metrics["f1",] <- metrics["f1",]/bootstraps
return(metrics)
}
normal.metrics <- ProduceAveragedPerfMetrics(X, Y, 5, 10)
permuted.metrics <- ProduceAveragedPerfMetrics(X, Yp, 5, 10)
print("Normal model performance metrics")
normal.metrics
print("Permuted model performance metrics")
permuted.metrics
# current page
knit2wp(input = 'Case Studies/Cases where the methods fail/SRBCT sPLS-DA Case Study (Permuted Labels).Rmd',
title = 'SRBCT sPLS-DA Case Study (Permuted Labels)',
shortcode = FALSE, publish = TRUE, action = c("newPage"))
setwd("C:/Users/Work/Desktop/UpdatedMixOmicsPages/All Pages")
knitr::opts_chunk$set(echo = TRUE)
library(RWordPress)
library(XML)
library(RCurl)
library(knitr)
## functon to upload images
#opts_knit$set(upload.fun = imgur_upload, base.url = NULL)
# username = 'password'
options(WordpressURL = c('http://mixomics.org/xmlrpc.php'))
options(WordpressLogin = c( "maxbladen" = "1Cg^ZOTlLJJoYAR(J@Obv!kf" ))
# note: you may have to play around with the following options 'http://mixomics.org/xmlrpc.php' (http, not https)
# current page
knit2wp(input = 'Case Studies/Cases where the methods fail/SRBCT sPLS-DA Case Study (Permuted Labels).Rmd',
title = 'SRBCT sPLS-DA Case Study (Permuted Labels)',
shortcode = FALSE, publish = TRUE, action = c("newPage"))
knitr::opts_chunk$set(echo = TRUE)
load('Data/nmt_data_processed.RData') # load the gastrulation data
load('Data/nmt_data_processed.RData') # load the gastrulation data
load('Data/nmt_data_processed.RData') # load the gastrulation data
X1 <- data$rna # select three of the five dataframes to explore
X2 <- data$met_genebody
X3 <- data$acc_genebody
X4 <- data$met_promoter
X5 <- data$acc_promoter
# compile these into a single X object
X <- list(rna = X1, met.gene = X2, acc.gene = X3,
met.pro = X4, acc.pro = X5)
lapply(X, dim) # check dimensions
