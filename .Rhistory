pch.levels=study,
subtitle="MINT sPLSDA",legend.title = "Inhibitor",
legend.title.pch = "Experiment", size.legend = rel(2.4),
size.legend.title = rel(2.5))
plotIndiv(ab.mint.splsda, study = "all.partial",ind.names = F,legend=T,
pch = as.numeric(factor(study))+15,
pch.levels=study, subtitle = paste("Study",1:2),
size.legend = rel(0.8),legend.title = "Inhibitor",
size.legend.title = rel(1))
plotLoadings(ab.mint.splsda, method = "median", comp = 1,
legend = T, study = "global", contrib = "max")
plotLoadings(ab.mint.splsda, method = "median", comp = 1,
legend = T, study = "all.partial", contrib = "max")
plotVar(ab.mint.splsda, var.names = FALSE,
pch = 16)
cim(ab.mint.splsda,
row.sideColors = color.mixo(as.numeric(treatment)),
save = 'jpeg', name.save = 'MINT Microbial CIM')
network(ab.mint.splsda, cutoff = 0.6,
color.node = c(color.mixo(1), color.mixo(2)),
shape.node = c("rectangle", "circle"),
save = 'jpeg', name.save = 'MINT Microbial Network')
auroc(ab.mint.splsda, roc.comp = 1)
auroc(ab.mint.splsda, roc.comp = 2)
auroc(ab.mint.splsda, roc.comp = 3)
ab.mint.splsda.perf <- perf(ab.mint.splsda)
plot(ab.mint.splsda.perf)
ExtractPredictionErrorRate <- function(comp) {
# store class prediction with a model of component
indiv.prediction <- predict.splsda$class$max.dist[, comp]
# generate the classification confusion matrix
conf.mat <- get.confusion_matrix(truth = treatment[indiv.test],
predicted = indiv.prediction)
return((sum(conf.mat) - sum(diag(conf.mat)))/sum(conf.mat))
}
indiv.test <- sample(1:nrow(abundance.processed), 16)
# train a model on studies 1,2 and 4
perf.splsda.model <- mint.splsda(X = abundance.processed[-c(indiv.test), ],
Y = treatment[-c(indiv.test)],
study = droplevels(study[-c(indiv.test)]),
ncomp = optimal.ncomp,
keepX = optimal.keepX)
# make predictions of stem cell type of study 3 samples
predict.splsda <- predict(perf.splsda.model, newdata = abundance.processed[indiv.test, ],
dist = "max.dist",
study.test = factor(study[indiv.test]))
ExtractPredictionErrorRate(1) # using first component only
ExtractPredictionErrorRate(2) # using first two components
ExtractPredictionErrorRate(3) # using all three components
View(metadata)
library(mixOmics) # import the mixOmics library
load("Microbial Data/mint_phenol_ammonia.RData") # load the data
View(abundance)
View(taxo)
View(heatmap_legend)
View(abundance)
TSS.divide = function(x){ # function to apply a TSS transformation to the data
x/sum(x)
}
# convert from raw to compositional data as well as transpose abundance so
# that OTUs are columns
t.abundance <- apply(t(abundance), 1, TSS.divide)
cat
# can see there is a lot of zeroes
cat("Number of zeroes prior to offset: ", length(which(t.abundance==0)))
abundance.offset <- t.abundance + 0.01 # apply offset
cat("Number of zeroes after offset: ", length(which(abundance.offset==0)))
which(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01)
colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01
which(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01)
(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01) == TRUE
length(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01)
which(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01, FALSE)
which(colSums(abundance.offset)*100/(sum(colSums(abundance.offset))) < 0.01, TRUE)
integer(0)
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(colSums(abundance.offset)*100/(
sum(colSums(abundance.offset))) < 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.filter <- result.filter$data.filter
abundance.filter
dim(abundance.filter)
knitr::opts_chunk$set(dpi = 100,
echo= TRUE,
warning=FALSE,
message=FALSE,
fig.show=TRUE,
fig.keep = 'all',
out.width = "70%")
library(mixOmics) # import the mixOmics library
load("Microbial Data/mint_phenol_ammonia.RData") # load the data
treatment <- metadata$inhib_inoc # extract the Y vector, the type of inoculant
study = metadata$experiment # extract the study each sample is from
TSS.divide = function(x){ # function to apply a TSS transformation to the data
x/sum(x)
}
# convert from raw to compositional data as well as transpose abundance so
# that OTUs are columns
t.abundance <- apply(t(abundance), 1, TSS.divide)
# can see there is a lot of zeroes
cat("Number of zeroes prior to offset: ", length(which(t.abundance==0)))
abundance.offset <- t.abundance + 0.01 # apply offset
cat("Number of zeroes after offset: ", length(which(abundance.offset==0)))
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(colSums(abundance.offset)*100/(
sum(colSums(abundance.offset))) < 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.filter <- result.filter$data.filter
dim(abundance.filter)
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(colSums(abundance.offset)*100/(
sum(colSums(abundance.offset))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.filter <- result.filter$data.filter
abundance.filter
dim(abundance.filter)
abundance.filter
t.abundance
t.abundance
abundance
t.abundance
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(colSums(abundance.offset)*100/(
sum(colSums(abundance.offset))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(t(abundance.offset), cutoff=0.01)
abundance.filter <- result.filter$data.filter
abundance.filter
abundance.offset
knitr::opts_chunk$set(dpi = 100,
echo= TRUE,
warning=FALSE,
message=FALSE,
fig.show=TRUE,
fig.keep = 'all',
out.width = "70%")
library(mixOmics) # import the mixOmics library
load("Microbial Data/mint_phenol_ammonia.RData") # load the data
treatment <- metadata$inhib_inoc # extract the Y vector, the type of inoculant
study = metadata$experiment # extract the study each sample is from
TSS.divide = function(x){ # function to apply a TSS transformation to the data
x/sum(x)
}
# convert from raw to compositional data as well as transpose abundance so
# that OTUs are columns
t.abundance <- apply(t(abundance), 1, TSS.divide)
abundance.offset <- t.abundance + 0.01 # apply offset
# can see there is a lot of zeroes
cat("Number of zeroes prior to offset: ", length(which(t.abundance==0)))
cat("Number of zeroes after offset: ", length(which(abundance.offset==0)))
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(colSums(abundance.offset)*100/(
sum(colSums(abundance.offset))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(t(abundance.offset), cutoff=0.01)
abundance.filter <- result.filter$data.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
cat("Number of OTU's remaining after filtering: ", ncol(abundance.filter))
abundance.offset
abundance.filter
abundance.filter
dim(abundance.filter)
abundance.offset
dim(abundance.offset)
abundance
dim(abundance)
abundance.offset
dim(abundance.offset)
abundance.filter
dim(abundance.filter)
abundance.offset
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(nowSums(data)*100/(
sum(nowSums(data))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(t(abundance.offset), cutoff=0.01)
abundance.filter <- result.filter$data.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
cat("Number of OTU's remaining after filtering: ", ncol(abundance.filter))
abundance.offset
abundance.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
abundance.offset
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.filter <- result.filter$data.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
cat("Number of OTU's remaining after filtering: ", ncol(abundance.filter))
abundance.offset
abundance.filter
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(nowSums(data)*100/(
sum(nowSums(data))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
abundance.filter <- result.filter$data.filter
abundance.offset
abundance.offset
dim(abundance.offset)
abundance.filter
knitr::opts_chunk$set(dpi = 100,
echo= TRUE,
warning=FALSE,
message=FALSE,
fig.show=TRUE,
fig.keep = 'all',
out.width = "70%")
library(mixOmics) # import the mixOmics library
load("Microbial Data/mint_phenol_ammonia.RData") # load the data
treatment <- metadata$inhib_inoc # extract the Y vector, the type of inoculant
study = metadata$experiment # extract the study each sample is from
TSS.divide = function(x){ # function to apply a TSS transformation to the data
x/sum(x)
}
# convert from raw to compositional data as well as transpose abundance so
# that OTUs are columns
t.abundance <- apply(t(abundance), 1, TSS.divide)
abundance.offset <- t.abundance + 0.01 # apply offset
# can see there is a lot of zeroes
cat("Number of zeroes prior to offset: ", length(which(t.abundance==0)))
cat("Number of zeroes after offset: ", length(which(abundance.offset==0)))
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(nowSums(data)*100/(
sum(nowSums(data))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
knitr::opts_chunk$set(dpi = 100,
echo= TRUE,
warning=FALSE,
message=FALSE,
fig.show=TRUE,
fig.keep = 'all',
out.width = "70%")
library(mixOmics) # import the mixOmics library
load("Microbial Data/mint_phenol_ammonia.RData") # load the data
treatment <- metadata$inhib_inoc # extract the Y vector, the type of inoculant
study = metadata$experiment # extract the study each sample is from
TSS.divide = function(x){ # function to apply a TSS transformation to the data
x/sum(x)
}
# convert from raw to compositional data as well as transpose abundance so
# that OTUs are columns
t.abundance <- apply(t(abundance), 1, TSS.divide)
abundance.offset <- t.abundance + 0.01 # apply offset
# can see there is a lot of zeroes
cat("Number of zeroes prior to offset: ", length(which(t.abundance==0)))
cat("Number of zeroes after offset: ", length(which(abundance.offset==0)))
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(rowSums(data)*100/(
sum(rowSums(data))) > 0.01)
data.filter = data[,keep.otu]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.offset
# function to remove any OTUs which has a count lower than cutoff % of the total
low.count.removal <- function(data, cutoff=0.01) {
keep.otu = which(rowSums(data)*100/(
sum(rowSums(data))) > 0.01)
data.filter = data[keep.otu,]
return(list(data.filter = data.filter, keep.otu = keep.otu))
}
result.filter <- low.count.removal(abundance.offset, cutoff=0.01)
abundance.filter <- result.filter$data.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
cat("Number of OTU's remaining after filtering: ", ncol(abundance.filter))
abundance.offset
abundance.filter
cat("Number of OTU's prior to filtering: ", nrow(abundance.offset))
cat("Number of OTU's remaining after filtering: ", nrow(abundance.filter))
summary(treatment)
knitr::opts_chunk$set(dpi = 100,
echo= TRUE,
warning=FALSE,
message=FALSE,
fig.show=TRUE,
fig.keep = 'all',
out.width = "90%")
ab.mint.splsda.tuning <- tune(method = "mint.splsda",
X=abundance.processed,
treatment,
study = study,
validation = "Mfold",
folds = 5,
ncomp = 5,
nrepeat = 10,
test.keepX = seq(5,80, 5),
measure = 'BER', # balanced error rate
dist = "centroids.dist")
plotLoadings(ab.mint.splsda, method = "median", comp = 1,
legend = T, study = "global", contrib = "mine")
plotLoadings(ab.mint.splsda, method = "median", comp = 1,
legend = T, study = "global", contrib = "min")
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/Work/Desktop/UpdatedMixOmicsPages/All Pages")
library(RWordPress)
library(XML)
library(RCurl)
library(knitr)
## functon to upload images
#opts_knit$set(upload.fun = imgur_upload, base.url = NULL)
# username = 'password'
options(WordpressURL = c('http://mixomics.org/xmlrpc.php'))
options(WordpressLogin = c( "maxbladen" = "1Cg^ZOTlLJJoYAR(J@Obv!kf" ))
# note: you may have to play around with the following options 'http://mixomics.org/xmlrpc.php' (http, not https)
# current page
knit2wp(input = 'MINT/Stem Cells Case Study/MINT Stem cells Case Study.Rmd',
title = 'MINT Stem Cells Case Study',
shortcode = FALSE, publish = TRUE, action = c("newPage"))
library(mixOmics)
data(srbct)
X <- srbct$gene
Y <- srbct$class
splsda.result <- splsda(X, Y, keepX = c(10,5)) # run the method
vip <- vip(splsda.result)
vip_comp1 <- vip[c(selectVar(splsda.result, comp = 1)$name ),"comp1"]
vip_comp2 <- vip[c(selectVar(splsda.result, comp = 2)$name ),"comp2"]
barplot(vip_comp1, beside = TRUE, ylim = c(0, 40), legend = rownames(vip_comp1),
main = "VIP - Comp 1")
barplot(vip_comp2, beside = TRUE, ylim = c(0, 40), legend = rownames(vip_comp2),
main = "VIP - Comp 2")
barplot(vip_comp1, beside = TRUE, ylim = c(0, 40), legend = rownames(vip_comp1),
main = "VIP - Comp 1")
data(linnerud)
X <- linnerud$exercise
Y <- linnerud$physiological
linn.pls <- pls(X, Y)
linn.vip <- vip(linn.pls)
barplot(linn.vip,
beside = TRUE, col = c("lightblue", "mistyrose", "lightcyan"),
ylim = c(0, 1.7), legend = rownames(linn.vip),
main = "Variable Importance in the Projection", font.main = 4)
splsda.result$prop_expl_var
plotIndiv(splsda.result)
vip_comp1
splsda.result$Y
ncol(splsda.result)
ncol(splsda.result$Y)
ncol(splsda.result$X)
splsda.result$loadings$X
object <- splsda.result
W = object$loadings$X
H = object$ncomp
q = ncol(object$Y)
p = ncol(object$X)
VIP = matrix(0, nrow = p, ncol = H)
VIP
cor2 = cor(object$Y, object$variates$X, use = "pairwise")^2
q
cor2 = cor(object$Y, object$variates$X, use = "pairwise")^2
object$Y = object$ind.mat
object$ind.mat
object$Y
q = ncol(object$Y)
q
cor2 = cor(object$Y, object$variates$X, use = "pairwise")^2
cor2
cor2 = as.matrix(cor2, nrow = q)
cor2
W[, 1]
W
q
cor2[, 1:h]
for (h in 2:H)
{
Rd = apply(cor2[, 1:h], 2, sum)
VIP[, h] = Rd %*% t(W[, 1:h]^2) / sum(Rd)
}
h
H
cor2[, 1:h]
Rd
colSums(cor2)
q
library(mixOmics)
data(srbct)
X <- srbct$gene
Y <- srbct$class
nrow(X)
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10)
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10))
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10))
sample
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10), 3:46)
length(sample)
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10), 3:45)
length(sample)
sample
design <- data.frame(sample = sample)
design
Xw <- withinVariation(X, design)
Xw <- withinVariation(X[1:20], design[1:20])
Xw <- withinVariation(X[1:20], design[1:20,])
Xw <- withinVariation(X[1:20, ], design[1:20])
X[1:20, ]
dim(X[1:20, ])
design[1:20]
Xw <- withinVariation(X[1:20, ], design[1:20,])
design[1:20,]
Xw <- withinVariation(X[1:20, ], sample[1:20,])
Xw <- withinVariation(X[1:20, ], sample[1:20])
Xw <- withinVariation(X=X[1:20, ], design=sample[1:20])
sample[1:20]
deisgn
design
design[1:20, ]
design[1:20, 1]
Xw <- withinVariation(X=X[1:20, ], design=design[1:20, 1])
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10))
design <- data.frame(sample = sample)
Xw <- withinVariation(X=X[1:20, ], design=design)
library(mixOmics)
data(srbct)
X <- srbct$gene
Y <- srbct$class
# pretend that the first 20 samples from this dataset are of repeated design
sample <- c(rep(c(1,2), 10))
design <- data.frame(sample = sample)
X.r <- X[1:20, ]
X.r.w <- withinVariation(X = X.r, design = design)
X.R
X.r
dim(X.r)
X.r.w
dim(X.r.w)
View(X.r.w)
Y
# pretend that the first 20 samples from this dataset are of repeated design
repeated.samples <- sample(1:63, 20)
library(mixOmics)
data(srbct)
X <- srbct$gene
Y <- srbct$class
# pretend that the first 20 samples from this dataset are of repeated design
repeated.samples <- sample(1:63, 20)
sample <- c(rep(c(1,2), 10))
design <- data.frame(sample = sample)
X.r <- X[repeated.samples, ]
X.r.w <- withinVariation(X = X.r, design = design)
View(X.r.w)
Y[repeated.samples]
repeated.samples
# pretend that the first 20 samples from this dataset are of repeated design
repeated.samples <- sort(sample(1:63, 20))
repeated.samples
# pretend that the first 20 samples from this dataset are of repeated design
set.seed(1234)
repeated.samples <- sort(sample(1:63, 20))
repeated.samples
repeated.samples <- 1:20 #sort(sample(1:63, 20))
Y[repeated.samples]
Y
sample <- to_list(for (x in 1:10) sample=c(sample, c(x,x)))
sample <- (for (x in 1:10) sample=c(sample, c(x,x)))
sample
sample <- c(for (x in 1:10) sample=c(sample, c(x,x)))
sample
sample <- c(1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10)
design <- data.frame(sample = sample)
design
X.r <- X[repeated.samples, ]
X.r.w <- withinVariation(X = X.r, design = design)
View(X.r)
X[-repeated.sample, ]
X[-repeated.samples, ]
dim(X[-repeated.samples, ])
X.final <- rbind(X.r.w, X[-repeated.samples, ])
X.final
dim(X.final)
View(X.final)
model <- splsda(X.final, Y, keepX = c(15,15))
plotIndiv(model)
plotIndiv(splsda(X, Y, keepX = c(15,15)))
View(X)
?prcomp
data("liver.toxicity")
data("liver.toxicity")
Y <- liver.toxicity$clinic
X <- liver.toxicity$gene
Y
